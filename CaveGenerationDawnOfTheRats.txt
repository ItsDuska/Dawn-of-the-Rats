Maailma koostuu listasta chunkkeja, jotka ovat saman kokosia esim 512.

jokainen chunk on joko iso luola tai pieni luola joka yhdistyy isompiin luoliin.

jokainen iso luola luodaan perlin noisen avulla ja se antaa jokaisen palikan kohdalle joko ykkösen tai nollan eli palikka tai ei palikkaa. esim:
{
100111
100011
110011
111001
}

pienet luolat luodaan kahden pisteen avulla eli suora viiva ja siihen päälle sin wave arvoja.

käyttäen listaa joka sisältää 1 tai nollan, valitsemme minkä textuurin laitamme kohtaan. biomeita voidaan käyttää eri palikoille tai random arvoa.

palikoiden päälle pystyy laittamaan toisia palikoita. esim yhdessä palikassa on ruohoa ja lampun jalka.

tutkitut chunkit jotka unloadataan tallennetaan tiedostoon ja ladataan uudelleen sieltä jos pelaaja palaa alueelle.


collisioniin vaan pelaajan ympärillä olevat palikat eli grid size ois 3x3
renderaa vaan näytöllä näkyvät hommat



TEE SPRITE JOKAISELLE PALIKALLE JOTKA OVAT TARKOITETTU VAIN YKSINÄISELLE PALIKALLE


maailma on esim 5x11 chunkkia ja pelaaja alkaa ylhäältä ja yrittää päästä alas


spriteSheet Toiminto:

Sprite sheet menee sen mukaan, että jokaiselle eri palikkatyypille (esim ruoho ja kivi) saman suuntaiset palikat on samassa kohtaa mutta y akseli on aina tietyn verran offSettinä.
Tän avulla koodin puolella voidaan vaan katsoa aluksi, että onko palikka kulma palikka ja sen perusteella saadaan kordinaatit tekstuurissa siihen. 
Tämän jälkeen katsotaan mikä palikka on kyseessä ja sen perusteella lisätään tekstuurin y kordinaattiin tietty luku esim 6.

Sprite sheetissä textuurit menis näin palikalle:
1-4 tarkottaa suuntaa esim 1 = vasenylä- ja 4 oikea-alakulma
suorien palikoiden suunta menee ilmansuuntien mukaan. 

kulma = K
suora = S
Tausta = T
L muotonen pala = L
yksinäinen palikka on = O
 a-g.. merkki tarkoittaa saman palikan varient 

Index:
0,  1,  2,  3,  4,   5,   6,   7,   8,   9,   10, 11, 12, 13, 14, 15, 16, 17, 18, 19
merkki:
K1, K2, K3, K4, SNa, SNb, SNc, SSa, SSb, SSc, SW, SE, Ta, Tb, Tc, L1, L2, L3, L4, O


jokanen on 1 tai 0
[0,1,2,3,4,5,6,7]


jos naapureissa on vain yks palikka tai jokaisessa kulmassa on yks palikka niin texture on yhdelle palikalle




Spudo Code textuuri valintaa varten:


Vector2i tileSize = {x,y};
Vector2i neighbors[8];
bool neighborBlocks[8];

for (int index = 0; index < 8; index++) // [0,1], [0,0] lista
{
	if (!isInBounds(position + neighbors[index], gridSize)) 
	{
		neighborBlocks[index] = true;
		continue;
	}
	neighborBlocks[index] = getCaveBlock(position+neighborBlocks[index]);
	
}
vector2i texCoord = getTexCoord(neighborBlocks);
createQuad(&quad[posInVertexArray], position, texCoord, tileSize);

//bittien tapaan hankitaan jokainen arvo
tee skripti pyyttonil ja laita arvot txt tiedostoon ja lue sieltä kaikki järjestykset


vector2i getTexCoord(bool neighborBlocks[])
{
}

katso vain tietyt kulmat eli ne mihin tulee kulmat ja suorat. 
else:
texCoord.x = 19


/////////////////////////////////////////////////////////
chunkki handlaajan koodi esimerkki miten se voisi toimia:
/////////////////////////////////////////////////////////

//view on se joka päättää tietyn alueen maailmasta ikkunalle.

/////////////
hpp tiedosto:
////////////

// windowSize avulla katsotaan kuinka kaukana pelaajasta chunkki on.
//Chunk classilla on chunk pos joka on esimerkiksi {0,0}, tai {0,1}
// save tallentaa chunkin vertexit tiedostoon.
// load lataa tallennetun chunkin tiedostosta chunks listaan.


class ChunkHandler
{
private:
	int seed;
	float threshold;
	sf::Vector2i gridSize;
	std::vector<*Chunk> chunks;
	sf::Vector2i windowSize; 
	void save(sf::vector2i chunkPosition);
	void load(sf::vector2i chunkPosition);
	void addChunk(int seed, float threshold, sf::Vector2i gridSize);
	void removeChunk(sf::Vector2i chunkPosition);
	void clearAllChunks(); //when game is over
	bool isInWindow(playerPosition);
public:
	void update(Vector2f playerPosition,View view);
	ChunkHandler(Vector2i windowSize,int seed, float threshold, sf::Vector2i gridSize);
	~ChunkHandler();
};



/////////////
cpp tiedosto:
/////////////


ChunkHandler::ChunkHandler(Vector2i windowSize, int seed, float threshold, sf::Vector2i gridSize)
{
	this->windowSize = windowSize;
	this->seed = seed;
	this->threshold = threshold;
	this->gridSize = gridSize;
	addChunk(chunkPosition = 0,0);
}


ChunkHandler::update(Vector2f playerPosition,View view)
{
	for chunk in chunks
	{
		if(!isInWindow(chunk.getChunkPosition(),playerPosition);
		{
			get current chunkPosition() ja katso missä ikkunan kulmassa on tyhjää
			addChunk(new chunkPosition, seed ja muut);
		}
		else
		{
			save(chunk.getChunkPosition())
			removeChunk(chunk.getChunkPosition());
		}
	}
}


bool ChunkHandler::isInWindow(chunkPosition,playerPosition)
{
	return if (chunk on ruudulla (pelaaja on keskipiste));
}


//Save ja load kannattaa tehdä uudella threadilla
//Jokaiselle chunkille on oma tiedostonsa jotka tallentuvat omaan kansioon nimeltä save tai jotain.

//clearAllChunks kutsutaan kun pelaaja kuolee tai häviää pelin. Tämä funktio tyhjetää chunks listan ja poistaa jokaisen chunkin save filen



Teoria miksi chunkit menee hassusti:
chunkit x ja y arvot on vääripäi.
vertex array alkaa rakentamaan quadeja tälleen:
1 = quad
0 = empty
1,1,1,1,1,1,1
1,0,0,0,0,0,0  
1,1,1,0,0,0,0
eli eka luodaan x rivi ja siihen jokainen y rivi. 

Elikkäs sillon kuin currentChunkPosition lasketaan niin sen pitäisi olla näin.

CurrentChunk_x = player.x / (gridSize.y * BLOCK_SIZE);
CurrentChunk_y = player.y / (gridSize.x * BLOCK_SIZE);

Jos Pelaaja on TIETYN_MATKAN_PÄÄSSÄ loadatusta chunkita:
	CHunk voidaan Renderaa = trues
	
	
	
	
GUI:

voitaisiin renderaa esim 30 kertaa per sekuntti eikä 60.

renderaa bäckgroundina se empty inventory ja piirrä päälle itemit



Item Class:

sit on staff class ja muita eri item classeja jotka herittaa itemista
jokasella on oma funktiot ja image path sekä tarvittaessa sound


Sound itemien equipmentille.



Sound Manager class.


 
Enemy class ja managerit tai jotain
Jokaiselle ai.
boss ai.


//////////////////////
MITÄ PITÄÄ SIIS TEHDÄ:
//////////////////////


World Generation
isojen luolien generaatio.
luolien yhdistyminen toisiinsta pienillä luolilla.
luolien outojen muotojen generoituminen.
texture generation for the blocks.
Inventory system
sound system
Enemies and the ai
collisions.
pimeys effecti koska olemme luolassa.
lighting system eli bloomia. varmaa uus fragment shaderi tarvitaan.
shadows ehkä.
Pelaajan hyppy ja gravitaatio.
Hyökkäys eli onko se melee vai ranged attack.
boss ja sen ai.
save systeemi ehkä?
damage systeemi
starting room ja boss room.
loot chest system.
item collection.
storing the items.
ovet ja lukitut ovet.
ansat.
Health bar ja mana bar.
current score.
end screen eli se joka tulee kun kuolet tai voitat pelin. (näkyy statsit)
stats system eli pidetään runin statsit kuten tapettujen vihollisten määrä tallessa.
Kaikki textuurit.
Ääänet ja musiikit.
hieman tarinaa joka yhdistäis paikan yhteen.
particle system.
